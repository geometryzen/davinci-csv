{"version":3,"file":"index.js","sources":["../../src/lib/CSV.ts"],"sourcesContent":["\n/**\n * A field in a comma-separated file is either a number, a string, or null.\n */\nexport type Field = number | string | null;\n\n/**\n * A format for relational data.\n */\nexport interface Data {\n    fields: { id: string }[];\n    records: { [fieldId: string]: Field }[];\n}\n\n/**\n * Options used for customizing parsing and serialization.\n */\nexport interface Dialect {\n    /**\n     * Specifies the delimiter between fields.\n     * Default is the comma, </code>','</code>.\n     * Used for parsing and serialization.\n     */\n    fieldDelimiter?: string;\n\n    /**\n     * Determines whether embedded quotation marks in strings are escaped during <em>serialization</em> by doubling them.\n     * Default is <code>true</code>.\n     */\n    escapeEmbeddedQuotes?: boolean;\n\n    /**\n     * Specifies the character used to terminate a line.\n     * Default is a single newline character, <code>'\\n'</code>.\n     * Used for parsing and serialization.\n     */\n    lineTerminator?: string;\n\n    /**\n     * The character used for quoting string fields.\n     * Default is the double quote, <code>'\"'</code>.\n     * Used for parsing and serialization.\n     */\n    quoteChar?: string;\n\n    /**\n     * Skips the specified number of initial rows during <em>parsing</em>.\n     * Default is zero, <code>0</code>.\n     */\n    skipInitialRows?: number;\n\n    /**\n     * Determines whether fields are trimmed during <em>parsing</em>.\n     * Default is <code>true</code>.\n     */\n    trimFields?: boolean;\n}\n\n/**\n * For internal conceptual integrity.\n */\ninterface NormalizedDialect {\n    delim: string;\n    escape: boolean;\n    lineTerm: string;\n    quoteChar: string;\n    skipRows: number;\n    trim: boolean;\n}\n\n/**\n * Regular expression for detecting integers.\n */\nconst rxIsInt = /^\\d+$/;\n\n/**\n * Regular expression for detecting floating point numbers (with optional exponents).\n */\nconst rxIsFloat = /^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/;\n\n// If a string has leading or trailing space,\n// contains a comma double quote or a newline\n// it needs to be quoted in CSV output\nconst rxNeedsQuoting = /^\\s|\\s$|,|\"|\\n/;\n\n/**\n * A polyfill in case String.trim does not exist.\n */\nconst trim = (function () {\n    // Fx 3.1 has a native trim function, it's about 10x faster, use it if it exists\n    if (String.prototype.trim) {\n        return function (s: string) {\n            return s.trim();\n        };\n    } else {\n        return function (s: string) {\n            return s.replace(/^\\s*/, '').replace(/\\s*$/, '');\n        };\n    }\n}());\n\n/**\n *\n */\nfunction chomp(s: string, lineterminator: string): string {\n    if (s.charAt(s.length - lineterminator.length) !== lineterminator) {\n        // Does not end with \\n, just return string.\n        return s;\n    }\n    else {\n        // Remove the newline.\n        return s.substring(0, s.length - lineterminator.length);\n    }\n}\n\n/**\n * Replaces all the funky line terminators with a single newline character.\n */\nfunction normalizeLineTerminator(csvString: string, dialect: Dialect = {}): string {\n    // Try to guess line terminator if it's not provided.\n    if (!dialect.lineTerminator) {\n        return csvString.replace(/(\\r\\n|\\n|\\r)/gm, '\\n');\n    }\n    // if not return the string untouched.\n    return csvString;\n}\n\n/**\n * Converts from the fields and records structure to an array of arrays.\n * The first row in the output contains the field names in the same order as the input.\n */\nexport function dataToArrays(data: Data): Field[][] {\n    const arrays: Field[][] = [];\n    const fieldIds = data.fields.map(field => field.id);\n    arrays.push(fieldIds);\n    for (const record of data.records) {\n        const tmp = fieldIds.map(fieldId => record[fieldId]);\n        arrays.push(tmp);\n    }\n    return arrays;\n}\n\n/**\n */\nfunction normalizeDialectOptions(dialect?: Dialect): NormalizedDialect {\n    // note lower case compared to CSV DDF.\n    const options: NormalizedDialect = {\n        delim: ',',\n        escape: true,\n        lineTerm: '\\n',\n        quoteChar: '\"',\n        skipRows: 0,\n        trim: true\n    };\n    if (dialect) {\n        if (typeof dialect.fieldDelimiter === 'string') {\n            options.delim = dialect.fieldDelimiter;\n        }\n        if (typeof dialect.escapeEmbeddedQuotes === 'boolean') {\n            options.escape = dialect.escapeEmbeddedQuotes;\n        }\n        if (typeof dialect.lineTerminator === 'string') {\n            options.lineTerm = dialect.lineTerminator;\n        }\n        if (typeof dialect.quoteChar === 'string') {\n            options.quoteChar = dialect.quoteChar;\n        }\n        if (typeof dialect.skipInitialRows === 'number') {\n            options.skipRows = dialect.skipInitialRows;\n        }\n        if (typeof dialect.trimFields === 'boolean') {\n            options.trim = dialect.trimFields;\n        }\n    }\n    return options;\n}\n\n// ## serialize\n//\n// See README for docs\n//\n// Heavily based on uselesscode's JS CSV serializer (MIT Licensed):\n// http://www.uselesscode.org/javascript/csv/\n\n/**\n * Converts from structured data to a string in CSV format of the specified dialect.\n */\nexport function serialize(data: Data | Field[][], dialect?: Dialect): string {\n    const a: Field[][] = (data instanceof Array) ? data : dataToArrays(data);\n    const options = normalizeDialectOptions(dialect);\n\n    const fieldToString = function fieldToString(field: string | number | null): string {\n        if (field === null) {\n            // If field is null set to empty string\n            field = '';\n        }\n        else if (typeof field === \"string\" && rxNeedsQuoting.test(field)) {\n            if (options.escape) {\n                // FIXME: May need to be the quote character?\n                field = field.replace(/\"/g, '\"\"');\n            }\n            // Convert string to delimited string\n            field = options.quoteChar + field + options.quoteChar;\n        }\n        else if (typeof field === \"number\") {\n            // Convert number to string\n            field = field.toString(10);\n        }\n\n        return field;\n    };\n\n    /**\n     * Buffer for building up the output.\n     */\n    let outBuffer = '';\n\n    for (let i = 0; i < a.length; i += 1) {\n        /**\n         * The fields we are currently processing.\n         */\n        const fields = a[i];\n\n        /**\n         * Buffer for building up the current row.\n         */\n        let rowBuffer = '';\n\n        for (let j = 0; j < fields.length; j += 1) {\n            /**\n             * Buffer for building up the current field.\n             */\n            let fieldBuffer = fieldToString(fields[j]);\n            // If this is EOR append row to output and flush row\n            if (j === (fields.length - 1)) {\n                rowBuffer += fieldBuffer;\n                outBuffer += rowBuffer + options.lineTerm;\n                rowBuffer = '';\n            }\n            else {\n                // Add the current field to the current row\n                rowBuffer += fieldBuffer + options.delim;\n            }\n        }\n    }\n\n    return outBuffer;\n}\n\n/**\n * Normalizes the line terminator across the file.\n */\nfunction normalizeInputString(csvText: string, dialect?: Dialect) {\n    // When line terminator is not provided then we try to guess it\n    // and normalize it across the file.\n    if (!dialect || (dialect && !dialect.lineTerminator)) {\n        csvText = normalizeLineTerminator(csvText, dialect);\n    }\n\n    const options = normalizeDialectOptions(dialect);\n\n    // Get rid of any trailing \\n\n    return { s: chomp(csvText, options.lineTerm), options };\n}\n\n/**\n * Parses a string representation of CSV data into an array of arrays of fields.\n * The dialect may be specified to improve the parsing.\n */\nexport function parse(csvText: string, dialect?: Dialect): Field[][] {\n\n    const { s, options } = normalizeInputString(csvText, dialect);\n    /**\n     * Using cached length of s will improve performance and is safe because s is constant.\n     */\n    const sLength = s.length;\n\n    /**\n     * The character we are currently processing.\n     */\n    let ch = '';\n    let inQuote = false;\n    let fieldQuoted = false;\n\n    /**\n     * The parsed current field\n     */\n    let field: Field = '';\n\n    /**\n     * The parsed row.\n     */\n    let row: Field[] = [];\n\n    /**\n     * The parsed output.\n     */\n    let out: Field[][] = [];\n\n    /**\n     * Helper function to parse a single field.\n     */\n    const parseField = function parseField(fieldAsString: string): string | number | null {\n        if (fieldQuoted) {\n            return fieldAsString;\n        }\n        else {\n            // If field is empty set to null\n            if (fieldAsString === '') {\n                return null;\n                // If the field was not quoted and we are trimming fields, trim it\n            }\n            else if (options.trim) {\n                fieldAsString = trim(fieldAsString);\n            }\n\n            // Convert unquoted numbers to their appropriate types\n            if (rxIsInt.test(fieldAsString)) {\n                return parseInt(fieldAsString, 10);\n            }\n            else if (rxIsFloat.test(fieldAsString)) {\n                return parseFloat(fieldAsString);\n            }\n            else {\n                // An example here is a heading which is not quoted.\n                return fieldAsString;\n            }\n        }\n    };\n\n    for (let i = 0; i < sLength; i += 1) {\n        ch = s.charAt(i);\n\n        // If we are at a EOF or EOR\n        if (inQuote === false && (ch === options.delim || ch === options.lineTerm)) {\n            field = parseField(field);\n            // Add the current field to the current row\n            row.push(field);\n            // If this is EOR append row to output and flush row\n            if (ch === options.lineTerm) {\n                out.push(row);\n                row = [];\n            }\n            // Flush the field buffer\n            field = '';\n            fieldQuoted = false;\n        }\n        else {\n            // If it's not a quote character, add it to the field buffer\n            if (ch !== options.quoteChar) {\n                field += ch;\n            }\n            else {\n                if (!inQuote) {\n                    // We are not in a quote, start a quote\n                    inQuote = true;\n                    fieldQuoted = true;\n                }\n                else {\n                    // Next char is quote character, this is an escaped quote character.\n                    if (s.charAt(i + 1) === options.quoteChar) {\n                        field += options.quoteChar;\n                        // Skip the next char\n                        i += 1;\n                    }\n                    else {\n                        // It's not escaping, so end quote\n                        inQuote = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Add the last field\n    field = parseField(field);\n    row.push(field);\n    out.push(row);\n\n    // Expose the ability to discard initial rows\n    if (options.skipRows) out = out.slice(options.skipRows);\n\n    return out;\n}\n"],"names":[],"mappings":"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"}