{"version":3,"file":"index.cjs.js","sources":["../../src/lib/CSV.ts"],"sourcesContent":["import Data from './Data';\nimport Dialect from './Dialect';\n\n/**\n * For internal conceptual integrity.\n */\ninterface NormalizedDialect {\n    delim: string;\n    escape: boolean;\n    lineTerm: string;\n    quoteChar: string;\n    skipRows: number;\n    trim: boolean;\n}\n\n/**\n * Rehular expression for detecting integers.\n */\nconst rxIsInt = /^\\d+$/;\n\n/**\n * Regular expression for detecting floating point numbers (with optional exponents).\n */\nconst rxIsFloat = /^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/;\n\n// If a string has leading or trailing space,\n// contains a comma double quote or a newline\n// it needs to be quoted in CSV output\nconst rxNeedsQuoting = /^\\s|\\s$|,|\"|\\n/;\n\n/**\n * A polyfill in case String.trim does not exist.\n */\nconst trim = (function () {\n    // Fx 3.1 has a native trim function, it's about 10x faster, use it if it exists\n    if (String.prototype.trim) {\n        return function (s: string) {\n            return s.trim();\n        };\n    } else {\n        return function (s: string) {\n            return s.replace(/^\\s*/, '').replace(/\\s*$/, '');\n        };\n    }\n}());\n\nfunction chomp(s: string, lineterminator: string): string {\n    if (s.charAt(s.length - lineterminator.length) !== lineterminator) {\n        // Does not end with \\n, just return string\n        return s;\n    }\n    else {\n        // Remove the \\n\n        return s.substring(0, s.length - lineterminator.length);\n    }\n}\n\n/**\n * Replaces all the funky line terminators with a single newline character.\n */\nfunction normalizeLineTerminator(csvString: string, dialect: Dialect = {}): string {\n    // Try to guess line terminator if it's not provided.\n    if (!dialect.lineTerminator) {\n        return csvString.replace(/(\\r\\n|\\n|\\r)/gm, '\\n');\n    }\n    // if not return the string untouched.\n    return csvString;\n}\n\n/**\n * Converts from the fields and records structure to an array of arrays.\n * The first row in the output contains the field names in the same order as the input.\n * @returns An array of arrays, [][], of (number|string|null) field values.\n */\nexport function dataToArrays(data: Data): (number | string | null)[][] {\n    const arrays: (string | number | null)[][] = [];\n    const fieldNames: string[] = [];\n    for (let ii = 0; ii < data.fields.length; ii++) {\n        fieldNames.push(data.fields[ii].id);\n    }\n    arrays.push(fieldNames);\n    for (let ii = 0; ii < data.records.length; ii++) {\n        const tmp: (string | number | null)[] = [];\n        const record = data.records[ii];\n        for (let jj = 0; jj < fieldNames.length; jj++) {\n            tmp.push(record[fieldNames[jj]]);\n        }\n        arrays.push(tmp);\n    }\n    return arrays;\n}\n\nfunction normalizeDialectOptions(dialect?: Dialect): NormalizedDialect {\n    // note lower case compared to CSV DDF\n    const options: NormalizedDialect = {\n        delim: ',',\n        escape: true,\n        lineTerm: '\\n',\n        quoteChar: '\"',\n        skipRows: 0,\n        trim: true\n    };\n    if (dialect) {\n        if (typeof dialect.fieldDelimiter === 'string') {\n            options.delim = dialect.fieldDelimiter;\n        }\n        if (typeof dialect.escapeEmbeddedQuotes === 'boolean') {\n            options.escape = dialect.escapeEmbeddedQuotes;\n        }\n        if (typeof dialect.lineTerminator === 'string') {\n            options.lineTerm = dialect.lineTerminator;\n        }\n        if (typeof dialect.quoteChar === 'string') {\n            options.quoteChar = dialect.quoteChar;\n        }\n        if (typeof dialect.skipInitialRows === 'number') {\n            options.skipRows = dialect.skipInitialRows;\n        }\n        if (typeof dialect.trimFields === 'boolean') {\n            options.trim = dialect.trimFields;\n        }\n    }\n    return options;\n}\n\n// ## serialize\n//\n// See README for docs\n//\n// Heavily based on uselesscode's JS CSV serializer (MIT Licensed):\n// http://www.uselesscode.org/javascript/csv/\n\n/**\n * Converts from structured data to a string in CSV format of the specified dialect.\n */\nexport function serialize(data: Data | (string | number | null)[][], dialect?: Dialect): string {\n    const a: (string | number | null)[][] = (data instanceof Array) ? data : dataToArrays(data);\n    const options = normalizeDialectOptions(dialect);\n\n    const fieldToString = function fieldToString(field: string | number | null): string {\n        if (field === null) {\n            // If field is null set to empty string\n            field = '';\n        }\n        else if (typeof field === \"string\" && rxNeedsQuoting.test(field)) {\n            if (options.escape) {\n                // FIXME: May need to be the quote character?\n                field = field.replace(/\"/g, '\"\"');\n            }\n            // Convert string to delimited string\n            field = options.quoteChar + field + options.quoteChar;\n        }\n        else if (typeof field === \"number\") {\n            // Convert number to string\n            field = field.toString(10);\n        }\n\n        return field;\n    };\n\n    /**\n     * Buffer for building up the output.\n     */\n    let outBuffer = '';\n\n    for (let i = 0; i < a.length; i += 1) {\n        /**\n         * The fields we are currently processing.\n         */\n        const fields = a[i];\n\n        /**\n         * Buffer for building up the current row.\n         */\n        let rowBuffer = '';\n\n        for (let j = 0; j < fields.length; j += 1) {\n            /**\n             * Buffer for building up the current field.\n             */\n            let fieldBuffer = fieldToString(fields[j]);\n            // If this is EOR append row to output and flush row\n            if (j === (fields.length - 1)) {\n                rowBuffer += fieldBuffer;\n                outBuffer += rowBuffer + options.lineTerm;\n                rowBuffer = '';\n            }\n            else {\n                // Add the current field to the current row\n                rowBuffer += fieldBuffer + options.delim;\n            }\n        }\n    }\n\n    return outBuffer;\n}\n\n/**\n * Normalizes the line terminator across the file\n */\nfunction normalizeInputString(csvText: string, dialect?: Dialect) {\n    // When line terminator is not provided then we try to guess it\n    // and normalize it across the file.\n    if (!dialect || (dialect && !dialect.lineTerminator)) {\n        csvText = normalizeLineTerminator(csvText, dialect);\n    }\n\n    const options = normalizeDialectOptions(dialect);\n\n    // Get rid of any trailing \\n\n    return { s: chomp(csvText, options.lineTerm), options };\n}\n\n/**\n * Parses a string representation of CSV data into an array of arrays, [][]\n * The dialect may be specified to improve the parsing.\n * @returns An array of arrays, [][], of (number|string|null) field values.\n */\nexport function parse(csvText: string, dialect?: Dialect): (string | number | null)[][] {\n\n    const {s, options} = normalizeInputString(csvText, dialect);\n    /**\n     * Using cached length of s will improve performance and is safe because s is constant.\n     */\n    const sLength = s.length;\n\n    /**\n     * The character we are currently processing.\n     */\n    let ch = '';\n    let inQuote = false;\n    let fieldQuoted = false;\n\n    /**\n     * The parsed current field\n     */\n    let field: string | number | null = '';\n\n    /**\n     * The parsed row.\n     */\n    let row: (string | number | null)[] = [];\n\n    /**\n     * The parsed output.\n     */\n    let out: (string | number | null)[][] = [];\n\n    /**\n     * Helper function to parse a single field.\n     */\n    const parseField = function parseField(fieldAsString: string): string | number | null {\n        if (fieldQuoted) {\n            return fieldAsString;\n        }\n        else {\n            // If field is empty set to null\n            if (fieldAsString === '') {\n                return null;\n                // If the field was not quoted and we are trimming fields, trim it\n            }\n            else if (options.trim) {\n                fieldAsString = trim(fieldAsString);\n            }\n\n            // Convert unquoted numbers to their appropriate types\n            if (rxIsInt.test(fieldAsString)) {\n                return parseInt(fieldAsString, 10);\n            }\n            else if (rxIsFloat.test(fieldAsString)) {\n                return parseFloat(fieldAsString);\n            }\n            else {\n                // An example here is a heading which is not quoted.\n                return fieldAsString;\n            }\n        }\n    };\n\n    for (let i = 0; i < sLength; i += 1) {\n        ch = s.charAt(i);\n\n        // If we are at a EOF or EOR\n        if (inQuote === false && (ch === options.delim || ch === options.lineTerm)) {\n            field = parseField(field);\n            // Add the current field to the current row\n            row.push(field);\n            // If this is EOR append row to output and flush row\n            if (ch === options.lineTerm) {\n                out.push(row);\n                row = [];\n            }\n            // Flush the field buffer\n            field = '';\n            fieldQuoted = false;\n        }\n        else {\n            // If it's not a quote character, add it to the field buffer\n            if (ch !== options.quoteChar) {\n                field += ch;\n            }\n            else {\n                if (!inQuote) {\n                    // We are not in a quote, start a quote\n                    inQuote = true;\n                    fieldQuoted = true;\n                }\n                else {\n                    // Next char is quote character, this is an escaped quote character.\n                    if (s.charAt(i + 1) === options.quoteChar) {\n                        field += options.quoteChar;\n                        // Skip the next char\n                        i += 1;\n                    }\n                    else {\n                        // It's not escaping, so end quote\n                        inQuote = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Add the last field\n    field = parseField(field);\n    row.push(field);\n    out.push(row);\n\n    // Expose the ability to discard initial rows\n    if (options.skipRows) out = out.slice(options.skipRows);\n\n    return out;\n}\n"],"names":[],"mappings":"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"}